1. Теоретические вопросы
==================================================
Вопрос 1: Что такое FastAPI и какие его основные преимущества?

Ответ 1:
fastapi Это вебфреймворк предназначенный для создания бэкенд приложений и реализации логики api интерфейсов при
переходе по заданным маршрутам.
Его основные преимущества: 1)простота разработки (для сравнения в том же django для того чтобы разработать простейшее
приложение, нужно регистрировать его в settings, создавать url в url_patterns, и так далее, то в fastapi достаточно
просто объявить функцию эндпоинт и приложение уже работает). 2) независимость от какой либо БД (например тот же django
настаивает на применении django ORM). 3) Асинхронная реализация, что позволяет сделать приложение гораздо более
производительным "расспараллелив" нагрузку запросов. 4). Генерация автоматической документации
начиная от принимаемых данных, заканчивая возвращаемым ответом. Также есть интерактивный тестировщик docs swagger,
который позволяет одновременно смотреть документацию и тестировать эндпоинты.
Это основные преимущества этого
фреймворка.

==================================================
Вопрос 2: В чем разница между HTTP методами GET, POST, PUT, PATCH и DELETE?

Ответ 2:
I. Идемпотентные методы (не изменяют данные на сервере):
1. get - отвечает за выдачу данных не меняя данные существующие на сервере. Он работает только с path, query параметрами.
Этот метод используется для получения контента с сайта или страниц с формой которая уже предназначена для работы с
другими методами.
del - удаление сущности с сервера. Метод имдемпотентный, то есть он в случае если ресурс есть удаляет его, а если ресурса
нет то сообщает об этом не изменяя состояния сервера.

II. Неидемпотентные методы (изменяют данные на сервере):
2. post - внесение новых данных на сервер (например создание нового аккаунта, чтение данных из форм), отправка формы,
метод может создавать новые данные.
3. put - используется для обновления данных с полной заменой существующей на сервере сущности (иногда бывает этим
пренебрегают и реализуют частичное обновление данных через него не используя path метод). Если данные не существуют то
будут созданы новые.
4. patch - этот метод используется для точечного (частичного обновления данных, например город пользователя), но часто
этим методом пренебрегают и реализуют частичное обновление в put.
------------------------------------------------------------------------------------------------------------------
Все эти методы по сути могут принадлежать к одному url, например http://example.com/user/1/ , но каждый метод это
отдельный операционный обработчик со своей операцией пути.

==================================================
Вопрос 3: Что такое path параметры? Как и зачем они используются в FastAPI?

Ответ 3:
path - это параметры пути, они являются частью url, и служат ссылкой на конкретный ресурс, например номер
страницы с контентом, или номер заявки. Эти параметры являются обязательными, так как без них url не попадет на нужный
адрес. Простой пример параметра пути: https://www.example.com/user/100/, вот как раз 100 и есть параметр пути (при том
условии что это не статичный адрес, и может быть пользователь 50 и 99 и так далее). Для того, чтобы их использовать
нужно в декораторе маршрута в url прописать этот параметр в скобках {}, например "/users/{user_id}/", и также указать
этот параметр и его тип в функции операции пути. Также используя опцию starlette path, можно указывать в url
непосредственно пути к ресурсам, и даже другие url, например: "/images/{file:path}/" и теперь в url можно будет ввести
путь к файлу на ресурсе, например это будет выглядеть так: "/images/funny_cats/img1.jpg/" где "funny_cats/img1.jpg/"
будет воспринято как путь к ресурсу внутри сервера.

==================================================
Вопрос 4: Почему порядок маршрутов с фиксированными путями и параметрами пути важен? Приведи пример.

Ответ 4:
Маршрут с фиксированным путём должен находиться перед маршрутом с параметрами пути, так как может быть перехвачен
маршрутом с параметрами пути при случайном вводе такого же url. Пример есть два url маршрута,
1. Фиксированный "/ex1/test/" и 2. Динамический с параметром пути "/ex1/{string}/", так вот если во 2 маршрут случайно
попадёт url вида "/ex1/test/" и при этом он будет стоять спереди, фиксированный маршрут с url "/ex1/test/" ни когда не
будет вызван, так как будет перехвачен динамическим url, так как "test" это тоже строка. Отсюда закономерность
размещения маршрутов в fastapi, частные случаи и маршруты всегда должны идти сначала в первом порядке, а потом уже более
частные случаи.

==================================================
Вопрос 5: Что такое query параметры? Как их использовать и валидировать?

Ответ 5: query это дополнительные параметры ключ-значение которые содержатся в url, после знака "?". Они могут быть
обязательными и необязательными (для этого в функции операции пути нужно присвоить им значение по умолчанию). Часто
такие параметры используются для передачи дополнительной информации такой как номер страницы например, для фильтров и
так далее. Пример query параметров https://example.com/?page=1&limit=10, где ?page=1&limit=10 и есть query параметры.
Кстати в html форма если не указать метод отправки post, будет отправлять данные из полей в виде query параметров. С
этим нужно быть аккуратным так как эти параметры не должны содержать чувствительной информации, так как она видна в url
и её можно будет подсмотреть в логах браузера.

==================================================
Вопрос 6: В чем разница между обязательными и необязательными query параметрами?

Ответ 6:
Обязательные query параметры это те которым в функции операции пути не присвоено значение по умолчанию, и если их не
передать при запросе то будет 422 ошибка, об отсутствии части данных в запросе. А необязательные query параметры уже
имеют значение по умолчанию, а значит их ввод не требуется.

==================================================
Вопрос 7: Что такое alias для query параметра и когда его применяют?

Ответ 7:
alias для query (и не только) параметра, это псевдоним, который применяется для тех ситуаций когда на фронтенде этот
атрибут называется одним названием например "username", а на сервере существует своя система имён (например это
обусловленно моделями ORM) и там к примеру необходимо название "name", и тогда у свойства в поле прописывается псевдоним
alias с названием которое может быть принято pydantic валидаторами и корректно быть обработано на сервере.
Также в документации будет отображаться название именно из alias.

==================================================
Вопрос 8: Какие ограничения на query параметры (min_length, max_length, regex) можно задать?

Ответ 8:
Для query параметров существуют встроенные в объекте Query ограничения в виде:
ограничения длины строки min_length, max_length. regex (в новых версиях pydantic pattern) где вводимая строка должна
соответствовать заданному шаблону, например артикул r"ФЛ-\d{4}\.\d{2}", и в результате будет принята например строка
"ФЛ-1000.45". Также существуют ограничения для чисел ge (больше либо равно), gt (больше), le(меньше либо равно),
lt(меньше), что позволяет задавать диапазоны с верхней и нижней границей, например ge=18, lt=60, что обозначает что
число может быть равно либо больше 18, но меньше 60. Также можно реализовать свои кастомные ограничения в валидаторах
pydantic используя декораторы field_validator и model_validator реализуя более сложную логику проверки входных данных,
а с помощью model_validator в частности можно проверить значение зависимых друг от друга полей, например двух паролей,
что они совпадают. (все перечисленное выше работает не только с query но и с path, body параметрами).

==================================================
Вопрос 9: Как принимать несколько значений одного query параметра? Чем это удобно?

Ответ 9:
для того, чтобы принимать несколько значений query параметра, нужно в функции обработчике объявить массив, например так:
def endpoint(hobby:list[str]), что позволит принять несколько значений hobby, в виде массива. Такая реализация удобна
когда незивестно заранее количество передаваемых аргументов, то есть удобство в том, что не нужно заранее декларировать
нужное количество параметров, оно формируется по ходу выполнения перехода по маршруту. Url в таком случае будет
выглядеть например так: https://example.com/?hobby=tennis&hobby=bilyard&hobby=football

==================================================
Вопрос 10: Какие типы данных можно передавать в body запросов? Приведи примеры.

Ответ 10:
В body запросах как правило передаются параметры в формате json в виде пар ключ-значение. Которые как правило прописаны
в pydantic моделях (при чем если есть pydantic модель то не нужно объявлять что этот параметр body, fastapi сам поймет
под капотом что это тело запроса). Но также объявляя явно что параметр body можно задавать отдельные поля с данными.
Пример передаваемых по body запросу данных: {"username":"Михаил", "age": 34, "work":"backend-developer"}.
Кстати именно body параметры рекомендуются для передачи чувствительных данных, так как они не отображаются и не
сохраняются в истории браузера и не видны в url. Также body параметры подходят для передачи большого количества данных,
что будет очень неудобно сделать через те же query параметры, и уж практически невозможно через path параметры.

==================================================
Вопрос 11: Что такое Pydantic и почему он важен для FastAPI?

Ответ 11:
pydantic это важнейший компонент fastapi, он отвечает за валидацию входных данных. В его компетенции проверка типов
входных данных согласно прописанных моделей в которой указана строгая типизация. Также в pydantic есть свои механизмы
ограничений входных данных, а можно также и создавать гораздо более сложные ограничения используя валидаторы.
Суть pydantic - задание точной структуры входных данных с последующей её проверкой механизмами валидации. Также в случае
ошибки будет выдан точный ответ с локализацией что введено не верно, и pydantic покажет все ошибки (а не вылетит на 1
попавшейся). А также из удобств, можно использовать точечную нотацию, так как модель это по сути класс.
И fastapi поэтому использует именно pydantic, так как в нем есть механизмы валидации данных, генерации схем (что нужно
для документации), и другие полезные свойства.
Важно понимать что преимущества pydantic можно использовать не только в fastapi, его можно использовать в любых своих
проектах, где нужна четкая структура входных данных и всевозможные механизмы проверок значений этих данных, с точной
локализацией ошибок, какой параметр(ы) неправильный(е).
Часто для входных параметров используют data классы, но они по своим возможностям и рядом не стоят с pydantic моделями.
Так как data класс просто информирует о структуре, но не защищен от передачи ненужных атрибутов, и не валидирует входные
значения (если это только не реализовано через геттеры и сеттеры). Вот ещё одно преимущество pydantic это избавление от
огромного числа проверок условий if/else, то есть вся сложная логика валидации передаётся под капот pydantic.

==================================================
Вопрос 12: Как создавать модели Pydantic и что такое наследование моделей?

Ответ 12:
для того, чтобы создать модель pydantic нужно использовать наследование от класс BaseModel модуля pydantic, и
определить в ней нужные в данном контексте поля, указав их тип, и дополнительную метаинформацию, а также ограничения
например min_length и другие.
Наследование моделей может быть нужно для переопределения свойств родительских моделей (как и в стандартном ООП).
Простой пример есть базовая модель пользователя, с полями name, age, и есть расширенная модель в которой добавляются
поля с паролями для ввода данных пользователем (то есть паттерн разделения моделей).

==================================================
Вопрос 13: Как указывать примеры (examples) для моделей Pydantic?

Ответ 13:
примеры examples можно указать двумя способами. Пример для каждого поля в pydantic модели (в полях field), тогда можно
персонально для каждого поля прописать примеры examples, либо по одному примеру в example. А также можно в model_config
используя ConfigDict указать пример модели в параметре json_schema_extra, в нем нужно будет создать список examples и
в этом списке можно в виде словарей указать схему вводных данных, при чем можно указывать несколько вариантов ввода.
Указание схем нужно для отображения в документации, а также, чтобы не прописывать данные каждый раз в ручную при
тестировании эндпоинтов на swagger docs.

==================================================
Вопрос 14: Что такое параметр extra в Pydantic и как он влияет на валидацию?

Ответ 14:
Параметр конфигурации модели (model_config) extra отвечает за то, чтобы в входных данных в модель нельзя было передавать
атрибуты не прописанные в модели, иными словами это защита от лишних ключей, чтобы ещё больше контролировать входные
данные. Задаётся в конфигурации модели model_config с помощью ConfigDict, или напрямую в виде словаря {"extra":"forbid"}

Параметр extra конфигурации модели отвечает за поведение атрибутами которые переданы в входных данных, но при этом не
были прописаны в самой модели. Всего есть три режима "Ignore"-ни чего не делает с добавляемыми атрибутами (по умолчанию
если не устанавливать эту конфигурацию, работает именно Ignore),"Allow"-атрибуты разрешено добавлять в модель то есть
у модели появятся новые поля ,"Forbid" - запрещает передавать поля не указанные в модели, то есть будет вызывать ошибку
ValidationError если в передаваемых данных будут лишние поля.

==================================================
Вопрос 15: Что такое cookie и как она используется для сессий в FastAPI?

Ответ 15:
cookie это небольшой набор данных, хранящих информацию о пользователе в браузере пользователя, в них могут храниться
информация о предпочтениях пользователя например тема сайта, и другие настройки интерфейса. Размер их ограничен поэтому
в них стоит хранить только необходимую для взаимодействия с сервером информацию. Говоря в общих чертах, Cookie это
набор данных хранящийся на клиенте для эффективного взаимодействия с сервером.
Также Cookie можно использовать для сессий (канала связи) между сервером и пользователем. С помощью set_cookie, клиенту
устанавливаются cookie - некий идентификатор сессии, и он хранится и в браузере клиента и на сервере, при каждом
последующем запросе на сервер, под капотом будут передаваться куки, и сервер будет понимать кто перед ним. За счёт этого
пользователю не нужно будет авторизовываться на каждый запрос. Куки не стоит путать с бизнес-данными о пользователе, это
лишь соединение сервера и клиента, но также на сервере к этому сессионному идентификатору подвязаны уже реальные бизнес
данные клиента, и также в объекте который хранит данный ключ могут быть указаны такие сведения как авторизован клиент или
нет и так далее.
ВАЖНО! Cookie, нужно передавать защищённым способом, установив флаги httponly -> запрет на чтение куков из js,
secure для передачи их только по https (защита шифрованием), и simesite="lax" для защиты от csrf атак (межсетевых
запросов).

==================================================
Вопрос 16: Чем cookie отличаются от заголовков HTTP?

Ответ 16:
HTTP заголовки это строго задекларированные параметры для взаимодействия сервера и браузера (то есть по общепризнанной
договоренности), даже не смотря на, то что можно определять свои собственные заголовки вида "X-...". В целом заголовок
это одно свойство, а cookie (являются частным случаем заголовков) это уже целый набор опций но персонализированный под
конкретный сервер.

==================================================
Вопрос 17: Какая разница между методами accept файла как bytes и UploadFile в FastAPI?

Ответ 17:
bytes - это сопособ загрузки при котором файл записывается в оперативную память сервера, такой способ подходит для
небольших файлов, но есть риск, что файл окажется большого размера заполнит всю память и вызовет сбои на самом сервере.
Чтобы этого избежать в fastapi предусмотрен класс UploadFile, который также принимает файл, но если файл имеет больший
размер чем установленный в настройках, то сохраняет файл как временный на диске, что позволяет избежать перегрузки
оперативной памяти. Также UploadFile даёт доступ к метаданным файла, таким как размер файла, его название и так далее.

==================================================
Вопрос 18: Для чего используется HTTPException в FastAPI?

Ответ 18:
HTTPException это исключение которое возбуждается при ошибках http запросов, оно позволяет указать статус код и деталь
ошибки. Нужно для тех случаев когда нужно явно вызвать исключение, прерывая действие запроса.

==================================================
Вопрос 19: Как обрабатывать ошибки валидации RequestValidationError?

Ответ 19:
RequestValidationError обрабатывается в отдельном обработчике @app.exception_handler(RequestValidationError), его можно
разобрать на ошибки извлекая из него нужную информацию и отправив её например в виде ResponsePlainText, ключевое, что
можно извлечь информацию об ошибки и пути к ней, и форматировать её в более удобный вид.

==================================================
Вопрос 20: Что такое response_model и его роль в документации и валидации ответов?

Ответ 20:
response_model, это параметр декоратора функции операции пути, который отвечает за то, чтобы явным образом указать в
каком виде вернется выходная модель, что отобразирся в документации. А также fastapi будет проверять корректность
выходных данных, иными словами до этого проверялись только входные данные, а теперь проверяются и выходные данные.

==================================================
Вопрос 21: Как задать summary, description, tags и deprecated для маршрутов?

Ответ 21:
summary - название маршрута для документации, description - краткое описание функции (может быть заменено подробным
docstring функции с учётом markdown для красивого форматирования), tags - группировка маршрутов с конкретным обозначением
удобно использовать из enum классов для централизованного управления тегами. deprecated - предупреждение об устаревании
маршрута, маршрут ещё работает (но в документации он обозначается перечеркнутым текстом и соответствующей надписью).
Устанавливаются все эти параметры в декораторе операции пути, теги устанавливаются в списке в виде строки, например
tags=["tag_name"].

==================================================
Вопрос 22: Что делает параметр exclude_unset в Pydantic модели?

Ответ 22:
exclude_unset - при десереализации модели ключи которые не были явно указаны в параметрах, будут исключены.

==================================================
Вопрос 23: Как работает метод copy(update=...) у Pydantic моделей?

Ответ 23:
Метод copy(уже deprecated сейчас используется model_copy), за счёт update создаёт копию модели, и обновляет в модели
значения ключей который содержатся в передаваемой в update модели. Это используется для частичного обновления
параметров в path запросах.

==================================================
Вопрос 24: Чем отличаются методы PUT и PATCH?

Ответ 24:
PUT подразумевает перезапись существующих данных, или создание новых если они отсутствуют. Но на практике иногда бывает
что в PUT реализуют частичное обновление параметров, не реализуя отдельно слой PATCH.
PATCH предназначен как раз для частичного обновления данных, и в fasatapi как раз для этого может использоваться метод
модели copy(update=...), а также промежуточная модель (унаследованная от базовой) в которой все поля как раз заполнены
значениями по умолчанию None.

==================================================
Вопрос 25: Что такое path параметр со starlette path и как его использовать?

Ответ 25:
path это опция starlette, которую можно указать в маршруте, для того, чтобы в нем можно было принимать пути. Указывается
это так: https://example.com/resources/{file_path:path}/, теперь строки после https://example.com/resources/ в url будут
распознаны как пути, при этом поддерживаются разделители путей "/".

==================================================
Вопрос 26: Что такое Annotated и как используется в FastAPI?

Ответ 26:
Annotated это объект модуля typing, предназначенный для передачи в ожидаемый тип дополнительной метаинформации, туда
можно передать как функции проверки и валидации, так и простые свойства. Т.е. Annotated связывает ожидаемый тип с
метаинформацией, которая может быть любым объектом python. Как раз именно в качестве метафункций с  метапараметрами и
ограничениями в fastapi передаются такие объекты как Path, Query, Body и другие, вот простой пример связывания:
user:Annotated[User:Body()]  - в этой строке ожидается параметр user, который является моделью User, при этом это
параметры тела запроса Body.

==================================================
Вопрос 27: Как задавать числовые ограничения (ge, le и др.) для параметров?

Ответ 27:

==================================================
Вопрос 28: Чем Body отличается от Form и почему их нельзя использовать вместе?

Ответ 28:

==================================================
Вопрос 29: Как сделать редирект в FastAPI и для чего он нужен?

Ответ 29:

==================================================
Вопрос 30: Как группировать маршруты по тегам в FastAPI?

Ответ 30:

==================================================
Вопрос 31: Как передавать вложенные Pydantic модели в теле запроса?

Ответ 31:

==================================================
Вопрос 32: Как обеспечить безопасность cookie (secure, httponly)?

Ответ 32:

==================================================
Вопрос 33: Что такое dependency injection в FastAPI?

Ответ 33:

==================================================
Вопрос 34: Как тестировать FastAPI приложения?

Ответ 34:

==================================================
Вопрос 35: Какие есть способы кастомизации документации Swagger/ReDoc?

Ответ 35:

==================================================
Вопрос 36: Что такое дискриминаторы в Pydantic и зачем они нужны?

Ответ 36:

==================================================
Вопрос 37: Как контролировать включение/исключение полей в response_model?

Ответ 37:
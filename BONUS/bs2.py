import uuid
import base64

"""
Простой пример того, как Cookie и данные передаются в зашифрованном виде по протоколу https, TLS рукопожатие.
Основа взаимодействия базируется на следующем алгоритме:
1. Пользователь (браузер-клиент) заходит на сайт (сервер), получает публичный ключ (то есть тот ключ который может быть
известен абсолютно всем это ssl сертификат).
2. Браузер генерирует свой случайный секретный ключ.
3. Браузер сохраняет этот сессионный ключ у себя.
4. Браузер шифрует сессионный ключ для отправки его на сервер.
5. Браузер отправляет зашифрованный сессионный ключ на сервер.
6. Сервер получив этот ключ расшифровывает его с помощью приватного ключа.
7. Сервер сохраняет этот ключ у себя, далее браузер и сервер будут взаимодействовать через него.
============================================================================================================
ВАЖНО! И ГЛАВНОЕ! -> В основе всего этого лежит ассимитричное шифрование, то есть публичный и приватный ключ между собой
связаны математически, ключ клиента который он шифрует публичным ключом, потом возможно расшифровать только приватным
серверным ключом. (это ответ на вопрос почему этот ключ не может быть использован для перехвата данных).
============================================================================================================
Примечания:
1. я попоросил ИИ сгенерировать генератор ключей и шифрования/расшифровки, и чуть отрефактрил в классы для уровня 
абстракции это очень упрощённый пример: генерация ключей и шифрование/расшифрование.
2. В методы генерации/шифрования/дешифрования ключа вникать не нужно. Главное понять последовательность общения сервера 
и браузера в __main__, классы здесь лишь для абстракции.
3. Алгоритмы здесь использует простейшую идею из RSA — возведение в степень по модулю.
4. В целом здесь логика генерации/шифрования/дешифрования сильно упрощена (чтобы не перегружать репозиторий 
устанвленными пакетами). Цель проекта ответить на вопрос, как например Cookie передаются по сети и при этом не могут 
быть перехвачены по середине между клиентом и сервером злоумышленниками.
"""


class ServerGenerateKeys:
    @staticmethod
    def _gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    @classmethod
    def egcd(cls, a, b):
        if a == 0:
            return b, 0, 1
        else:
            g, y, x = cls.egcd(b % a, a)
            return g, x - (b // a) * y, y

    @classmethod
    def _modinv(cls, a, m):
        # Поиск обратного элемента по модулю (расширенный алгоритм Евклида)

        g, x, y = cls.egcd(a, m)
        if g != 1:
            raise Exception('Обратный элемент не существует')
        else:
            return x % m

    @classmethod
    def generate_keys(cls):
        # Очень маленькие простые числа, просто для демонстрации
        p = 31
        q = 97
        n = p * q  # модуль
        phi = (p - 1) * (q - 1)  # функция Эйлера

        e = 7  # выбираем e (обычно 65537, но 7 подходит тут)
        # Проверяем, что e и phi взаимно просты
        if cls._gcd(e, phi) != 1:
            raise Exception('e и phi взаимно не просты')

        d = cls._modinv(e, phi)  # рассчитываем d - секретный ключ
        return (e, n), (d, n)  # возврат: публичный и приватный ключ


class EncryptDecrypt:
    @staticmethod
    def encrypt(msg, pubkey):
        e, n = pubkey
        # Преобразуем каждый символ в число и шифруем
        cipher = [pow(ord(char), e, n) for char in msg]
        return cipher

    @staticmethod
    def decrypt(cipher, privkey):
        d, n = privkey
        # Расшифровываем по одному символу и переводим в буквы
        msg = ''.join([chr(pow(char, d, n)) for char in cipher])
        return msg


class BrowserGenerateSessionKey:
    @staticmethod
    def generate_secret_key():
        # браузер генерирует случайный ключ
        short_bytes = uuid.uuid4().bytes[:4]
        short_key = base64.urlsafe_b64encode(short_bytes).decode('utf-8').rstrip("=")
        return short_key


if __name__ == '__main__':
    # Демонстрация по шагам:
    # 1. сервер изначально сгенерировал два ключа публичный для передачи по сети, приватный (хранится только на сервере)
    public_key, private_key = ServerGenerateKeys.generate_keys()

    # 2. Клиент впервые посетил сайт и получил публичный ключ.
    browser_session_key = BrowserGenerateSessionKey.generate_secret_key()
    print("Секретный ключ сгенерированный браузером:", browser_session_key)
    # шифрует сессионный ключ используя публичн
    encrypted_session_key = EncryptDecrypt.encrypt(browser_session_key, public_key)
    print("По сети он будет передаваться в таком зашифрованном виде:", encrypted_session_key)

    # 3. Сервер расшифровывает ключ с помощью приватного ключа (который связан с публичным ключом)
    server_session_key = EncryptDecrypt.decrypt(encrypted_session_key, private_key)
    print("Сервер расшифровал ключ с помощью приватного ключа:", server_session_key)

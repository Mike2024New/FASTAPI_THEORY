import os

from UTILS.APP_RUN import app_run
from UTILS.read_file import read_file
from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.responses import HTMLResponse
from typing import Annotated

# http://127.0.0.1:8000/docs
# http://127.0.0.1:8000/redoc
app = FastAPI()
app.name = "app"

"""
В fastapi за приём файлов отвечает объект File, который может принимать файлы в двух видах:
1. В байтах, в таком случает данные записываются в оперативную память, но так делать настоятельно не рекомендуется, так
как оперативная память ограничена а отправка слишком большого файла может привести к сбою приложения и даже сервера.
2. Через объект UploadFile класс-модель которая наиболее эффективно управляет загрузкой файлов, например файл 
сохраняется в оперативной памяти до определенного размера и если он превышает этот размер, то данные будут сохранены в 
временный файл на диске, что поможет разгрузить оперативную память (и вообще избежать её перегруза) и работать с 
большими файлами, если в процессе выполнения кода не будет отдана команда на сохранение файла, то временный файл 
удалится и с диска тоже. Таким образом UploadFile это целый менеджер по управлению приёмом файла. 
------------------------------------------------------------------------------------------------------------------
Файлы по сети передаются с помощью бинарных данных (например: "11101111"), чтобы лучше понять это см. BONUS/bs4.py
Все операции с файлами должны выполняться в асинхронном режиме, иначе маршрут зависнет на первом же запросе (это про тот 
случай когда операции затратные по времени).
"""


@app.get("/")
def home():
    content = read_file(file_path=os.path.join(os.getcwd(), 'HTML', 'file3.html'))
    return HTMLResponse(content=content, status_code=200)


"""
ex1 ->
создание файла в оперативной памяти, такой способ подходит только для работы с небольшими файлами (несколько мегабайт 
максимум), так как отправка большого количества файлов может привести к перезаполненности памяти и вылету приложения и 
даже к сбою сервера. 
"""


@app.post("/ex1/")
async def ex1(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


"""
ex2 -> пример приёма файла от пользователя, через объект UploadFile, это класс который также строит прием файла на 
байтах, но в отличии от приёма файла с помощью bytes, записывает файл в оперативную память до определенного размера и в
случае превышения этого лимита сохраняет файл на диске (используя временные файлы), что очень удобно для пересылки 
больших файлов. По сути это менеджер байтов отвечающий за эффективное управление ими.
---------------------------------------------------------------------------------------------------------------------
В примере ex2, также приводится как корректно обработать отправку пустого файла (в документации fastapi, указано, что 
нужно обрабатывать просто через None, но это не верно, так как form возвращает пустую строку и с ней создаётся объект
UploadFile, а значит file ни когда не будет равен None, поэтому лучше проверять через пустую строку)
---------------------------------------------------------------------------------------------------------------------
ВАЖНО! Операции чтения файла и действий с ним должны выполняться в асинхронном режиме (добавить ключевое слово await), 
иначе это может вызвать подвисание маршрута если операция долгая.
"""


@app.post("/ex2/")
async def ex2(file: UploadFile | None = None):
    # файл также может отсутствовать, в таком случае, его имя будет пустым "" (так возвращает form из html)
    if not file or file.filename == "":  # порядок условий имеет значение
        return {"msg": "Не загружен файл"}

    # чтение файла, выполнение операции file.read()
    res = await file.read()  # важно! чтение файла идёт в асинхр. режиме, то есть использ await иначе маршрут зависнет
    try:
        text = res.decode('utf-8')  # перевод байтов в кодировку (декодирование)
    except UnicodeDecodeError:
        raise HTTPException(status_code=400, detail="Ошибка декодирования файла в utf-8")

    out_data = {
        "filename": file.filename,
        "file_size": len(res),
        "content_type": file.content_type,
        "preview": text[:50],
    }

    await file.close()  # закрытие файла, после выполнения всех операций над ним (обычно fastapi делает это автоматом)
    return out_data


"""
ex3 -> 
передача дополнительных метаданных для документации файлов.
Для этого используется объект File, который позволяет задавать эти метасвойства
"""


@app.post("/ex3/")
async def ex3(file: Annotated[UploadFile, File(
    title="файл пользователя",
    description="Отправьте текстовый файл .txt",
    media_type='multipart/form-data',
)]):
    res = await file.read()  # важно! чтение файла идёт в асинхр. режиме, то есть использ await иначе маршрут зависнет
    return {
        "filename": file.filename,
        "file_size": len(res),
        "content_type": file.content_type,
    }


"""
ex4 -> 
пакетная отправка файлов.
Fastapi также поддерживает приём нескольких файлов из формы, для этого нужно просто объявить список в аннотациях типа и
указать что в списке должны содержаться объекты UploadFile (или bytes в случае записи файлов в память).
"""


@app.post("/ex4/")
async def ex4(files: Annotated[
    list[UploadFile], File(description="загрузите несколько файлов")]
              ):  # теперь на вход принимаются несколько файлов
    files_data = [{"filename": file.filename} for file in files]  # псевдооперация обработки
    return files_data


if __name__ == '__main__':
    app_run(file=__file__, app_name=app.name)

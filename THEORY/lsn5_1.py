from UTILS.APP_RUN import app_run
from fastapi import FastAPI, Header
from typing import Annotated

# http://127.0.0.1:8000/docs
# http://127.0.0.1:8000/redoc
app = FastAPI()
app.name = "app"

"""
Header -> это управляющие заголовки между браузером и сервером (рассматриваемые в lsn4_x Cookie, это частный случай 
заголовков Header). Иными словами header, это универсальный "язык общения" между сервером и браузером, из согласованных
заголовков. Например браузер передаёт серверу заголовок User-Agent, и сервер видит, что подключается не бот а реальный
пользователь. Или браузер пишет в Accept и сервер понимает какой тип контента ждёт клиент.
Также с помощью заголовков сервер может управлять сессией, на пример Connection=keep-alive обозначает, что сессия 
продолжится после текущего запроса.
В свою очередь рассмотренные Cookie это "язык специализированных команд" для конкретного сервера.
Для того, чтобы в fastapi получить заголовки используются методики Request (это будет изучено далее в более продвинутой
части изучения fastapi) который позволяет принимать все заголовки, а также объект Header который принимает конкретные 
заголовки заданные в параметрах, о нем и пойдёт речь ниже.
"""

"""
ex1 -> принятие конкретных заголовков, например User-Agent, но так как в python нельзя использовать дефисы, то параметр
пишется в виде user_agent, то есть используется нижнее подчеркивание и снек кейс. А под капотом fastapi преобразует
все это в нормальный регистр и _ в дефис.
В целом HTTP заголовки считаются не чувствительными к регистру, и в запросах браузеры могут использовать разный регистр
(user-agent, User-Agent, USER-AGENT и все это поддерживается).
"""


@app.get("/ex1/")
async def ex1(user_agent: Annotated[str | None, Header()] = None, host: Annotated[str | None, Header()] = None):
    return {"User-Agent": user_agent, "Host": host}


"""
ex2 ->
Иногда, а возможно ни когда может понадобиться отключить автопреобразование заголовков в нормальный вид, например
параметр user_agent в User-Agent, так как это в браузере. И это можно запретить, для этого используется опция
convert_underscores = False.
Но тогда заголовки не будут читаться да и не все серверы такое поддерживают, поэтому эта опция скорее всего не 
понадобится.
"""


@app.get("/ex2/")
async def ex2(user_agent: Annotated[str | None, Header(convert_underscores=False)] = None):
    return {"непонятный заголовок": user_agent}


"""
ex3 ->
также можно принимать несколько заголовков с одним и тем же именем (система такая же как с дублирующимися query 
параметрами, значения этих заголовков сложатся в 1 массив).
Для этого в аннотациях нужно указать что на вход ожидается список.
"""


@app.get("/ex3/")
async def ex3(x_token: Annotated[list[str] | None, Header()] = None):
    return {"X-Token values": x_token}


if __name__ == '__main__':
    app_run(file=__file__, app_name=app.name)

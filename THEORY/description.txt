https://fastapi.tiangolo.com/ru/tutorial/

lsn0 - первое знакомство с Fastapi, запуск приложения через терминал, например: uvicorn THEORY.lsn0:app --reload,
это позволит переписывать сам файл (например менять эндпоинты) и сервер будет автоматически перезагружаться, что
удобно так как не нужно перезагружать приложение каждый раз в ручную. Чтобы остановить приложение в терминале использ
ctrl+c.

PATH ПАРАМЕТРЫ: ПАРАМЕТРЫ ПУТИ (методы get)  -> http://127.0.0.1:8000/page{page_id}/

    lsn1_1 - path параметры, которые являются частью пути (url), используются как правило для ссылки на какой
    либо ресурс, например номер заявки, страницы и так далее. Вот простой пример такого url,
    http://127.0.0.1:8000/page{page_id}/ где page_id в {} как раз и обозначает параметр пути. Локализация ошибок в
    случае неправильного ввода path параметра.

    lsn1_2 - Важность порядка размещения функций с фиксированным путем и параметрами пути,
    если их url совпадают. Ситуация когда есть фиксированный путь url, например /page/my_page/ и url с path параметрами
    /page/{num_page}/, важно разместить url с фиксированным путём выше, чем url с path параметрами иначе это приведет к
    непредсказуемому результату, когда url фиксированного пути будет перехвачен обработчиком url динамического пути.
    ВАЖНО! url фиксированного пути всегда идут на самом верхнем уровне.

    lsn1_3 - предопределение path параметров с помощью Enumerate перечислений и генерация интерактивной документации.

    lsn1_4 - пути в path параметрах, ситуация когда нужно указать путь (например: /cats/funny_cats/images/) в url, для
    этого используется опция starlette path, например url в эндпоинте теперь будет отображаться так: /{file_path:path}/
    что будет обозначать для fastapi ожидается ввод пути. Также в примере разобрана ситуация как комбинировать несколько
    path параметров и как их связать с параметром который ожидает путь. Пример первых тестов на requests из модуля
    UTILS.

    lsn1_5 - установка дополнительных параметров валидации в Path() объекте. Использование ge (больше либо равно),
    gt(больше), le (меньше либо равно), lt(меньше). Числовые диапазоны.

QUERY ПАРАМЕТРЫ: ДОПОЛНИТЕЛЬНЫЕ ПАРАМЕТРЫ В URL (методы get) -> http://127.0.0.1:8000/?show_pages=10&limit=2

    lsn2_1 - query параметры, это параметры в виде пар ключ значение, которые идут после url. Могут быть необязательными
    для этог нужно предустановить значение по умолчанию. А также обязательными. В примере рассматриваются разные типы
    query параметров. Синтаксис написания: http://127.0.0.1:8000/?par1=val1&par2=val2 где ?par1=val1&par2=val2 и есть
    как раз query параметры.
    Важно! Query параметры не подходят для передачи чувствительной информации (номеров дебетовых карт cvs кодов и
    так далее), так как видны в url и также могут быть сохранены в журнале браузера и могут попасть к злоумышленникам.

    lsn2_2 - комбинация path и query параметров в url. path параметр всегда содержится в url, а query параметр
    объявляется в функции контроллере, но не в url. Также path параметр всегда обязателен а query нет (если присвоено
    значениие по умолчанию).

    lsn2_3 - объект Query, установка дополнительных параметров и свойств query параметров. Установка Query свойств через
    Annotated (используется в typing для присвоения параметрам метаинформации). Старый способ записи без Annotated.
    До версий 3.9 Annotated импортируется из typing_extensions.

    lsn2_4 - Query установка ограничений входного значения параметра min_length, max_length, pattern (регулярные
    выражения), числовые параметры. Обязательный Query параметр без присвоения значения по умолчанию и обработка null в
    ручную в функции эндпоинте.

    lsn2_5 - предача списков в query или вызов query несколько раз. Присвоение списка по умолчанию через
    default_factory, чтобы гарантировать независимую копию списка.

    lsn2_6 - дополнительная метаинформация, title - название параметра отображаемое в документации, descriptions -
    описание параметра отобр в документации, depricated - предупреждение об устаревании параметра (то есть он ещё
    работает, но в доках отображается, что это устаревшая технология), alias псевдоним параметра, например нужно, чтобы
    для url он назывался query-par, но для python это имя не валидно, с помощью alias, можно связать
    query-par и query_par. Исключение параметра из схемы - include_in_schema (то есть параметр не будет отображаться в
    документации).

    lsn2_7 - группировка query параметров, pydantic модели можно использовать для группировки query параметров в группы.
    Связывание query и pydantic модели происходит через Annotated, с указанием в метаатрибутах объекта Query(). Важный
    нюанс про aliast и совместимость pydantic и fastapi, лучше в query-pydantic моделях воздержаться от их использования
    так как это может приводить к некоректному чтению результатов из url (пример со списками).
    Запрет на добавление лишних ключей в параметрах запроса extra = "forbid" в конфигурации модели.

BODY ПАРАМЕТРЫ: ПЕРЕДАЮТСЯ В ТЕЛЕ ЗАПРОСА (методы POST,PUT, DELETE)

    lsn3_1 - body параметры - это данные которые клиент отправляет в теле HTTP запроса (через POST, PUT, DELETE) в
    формате json. Они не фиксируются в истории и логах, их не видно в url, они отлично подходят для передачи
    чувствительной информации. Также в уроке рассмотренна комбинация path, query и body параметров, как Pydantic
    понимает кто есть кто.

    lsn3_2 - множество body параметров, особенность в том, что каждый параметр передается по своему ключу. Явное
    указание, что параметр является body параметром (если этого не сделать то параметр будет воспринят как query).

    lsn3_3 - embed=True, эта настройка в параметре Body, даёт возможность задавать правило, что единичные тела запроса
    (когда всего одно тело запроса), будут передаваться строго по ключу (название параметра).

    lsn3_4 - параметры полей модели запроса body, min_length, max_lengt,ge,gt, le, lt и так далее. Особенность работы с
    псевдонимами alias, опция populate_by_name в конфигурации модели, для возможности передавать названия и по
    псевдонимам и по названиям атрибутов.

    lsn3_5 - body вложенные модели. Несколько уровней вложенности pydantic моделей. Опциональные вложенные модели.
    Работа с вложенными моделями через точечную нотацию.

    lsn3_6 - дискриминатор и обощающий тип, когда несколько моделей одинакового уровня вложенности, нужно уместить в
    одну коллекцию. Обобщающий тип позволяет за счёт дискриминатора показать pydantic на прямую, какую модель сейчас
    стоит проверять и это позволяет делать точную локализацию всех ошибок. Когда без дискриминатора, pydantic выпадет
    на первой же ошибке, показывая не точную локализацию.
    Встроенные методы у моделий.

    lsn3_7 - объявление json схемы с примерами входных данных для pydantic моделей (это справедливо и для query
    параметров). Чтобы добавить свои примеры, нужно использовать конфигурацию json_schema_extra в model_config. А также
    можно напрямую прописывать примеры в атрибутах в поле field, прописывая примеры в опции examples в виде списка.
    Примеры для пользовательского ввода отображаются в документации swagger ui, redoc.

    lsn3_8 - различные типы данных в pydantic, pydantic поддерживает не только базовые типы данных, такие как
    int, float,str, bool но и более сложные типы данных, например datetime и другие типы данных, при чем под капотом он
    выполнит преобразование в этот тип.

COOKIE параметры:
    lsn4_1 - прием cookie файлов на стороне сервера. Объяснение концепции куки, смысл в том, что это отдельный канал
    данных который позволяет управлять взаимодействием клиента и сервера, собирать статистику о действиях клиента (для
    рекламы используется), избегать необходимости авторизации после каждой перезагрузки страницы и так далее.
    Рекомендация о том, что куки нужно передавать через https, установив TLS рукопожатие (подробнее об этой теме можно
    посмотреть в разделе BONUS/bs2.py).
    Cookie - это "специализированный набор комманд" установленный сервером, для взаимодействия с клиентом (в отличии от
    заголовков - стандартизированных опций HTTP запросов см. про них уроки lsn5_1).
    См. также подробные примеры работы с Cookie в BONUS/bs3.py и BONUS/bs3_requests.py, там показан простой пример
    авторизации и использования куки и сессии в куках.

    lsn4_2 - параметры cookie можно объявлять с помощью pydantic модели, образуя целые комбинации из куки параметров для
    запросов, это может быть удобным в том плане, что в конкретный эндпоинт будут приходить нужные параметры куков а не
    все подряд. В примере также рассмотрен способ установить Cookie, с помощью объекта Response и его метода set_cookie,
    и дополнительные опции безопасности этого метода. Response это объект из более продвинутых тем которые будут дальше
    но он нужен для более удобного объяснения дальнейших примеров.

HEADER параметры:

    lsn5_1 - Header -> это управляющие заголовки между браузером и сервером (рассматриваемые в lsn4_x Cookie, это
    частный случай заголовков Header). Иными словами header, это универсальный "язык общения" между сервером и
    браузером, из согласованных заголовков. Например браузер передаёт серверу заголовок User-Agent, и сервер видит, что
    подключается не бот а реальный пользователь. Или браузер пишет в Accept и сервер понимает какой тип контента ждёт
    клиент. Также с помощью заголовков сервер может управлять сессией, на пример Connection=keep-alive обозначает, что
    сессия продолжится после текущего запроса.

    lsn5_2 - объявление pydantic моделей для заголовков. Обработка Cookie в рамках header, распаковка строки (которая
    пришла с браузера) в словарь куков, с помощью field_validator с режимом before (работа с сырыми данными до проверки
    pydantic).

УПРАВЛЕНИЕ ОТВЕТОМ СЕРВЕРА ПОЛЬЗОВАТЕЛЮ (ВОЗВРАЩАЕМЫЕ МОДЕЛИ PYDANTIC):
    Аннотации выходного ответа response_model ещё нужны и для того, чтобы эта информация обозначалась в выходной
    документации.

    lsn6_1 - в функцях операции пути (эндпоинтах), также можно и нужно аннотировать типы возвращаемых пользователю
    данных. Эти данные могут быть моделями pydantic. В примере также показано, как разделять входные и выходные модели
    как принять модель содержащую чувствительные данные, а вернуть модель без этих данных, но содержащую все остальные
    поля, в частности для этого можно использовать response_model в декораторе операции пути.

    lsn6_2 - объект Response, как возвращение ответа сервера на прямую. ResponseRedirect перенаправление пользователя на
    другую страницу со статус кодами 301, 302. JSONResponse выдача клиенту контента содержимого в Response.
    Возвращаемый тип Response с другими типами в сигнатуре функции, важно нужно в таком случае установить параметр
    response_model=None в декораторе функции пути (эндпоинте).

    lsn6_3 - В декораторах функций операций пути, можно гибко управлять выдаваемыми данными избегая отправки лишних
    ключей (что может создать перегруженность у принимающего клиента). Например можно исключать не переданные ключи,
    или указывать в выдаче только конкретные ключи.
    Всего есть 5 таких режимов:
    response_model_exclude_unset = True - исключение ключей которые не были переданы в модель.
    response_model_exclude_default = True - ислкючение тех ключей значение которых равно значениям по умолчанию.
    response_model_exclude_none = True - исключение ключей значение которых равно None
    response_model_exclude = {"key1","key2"} эти ключи будут исключены из выдачи
    response_model_include = {"key1","key2"} только заданные в множестве ключи будут возвращены

    lsn6_4 - пример использования нескольких разных моделей, взаимосвязанных одной операцией пути. В данном примере,
    три модели обслуживают цепочку [ входные данные -> сохранение в БД -> выходные данные ], и для каждой операции есть
    своя модель, а модель которая обслуживает операцию сохранение в БД, не имеет ни какой связи с клиентом и действует
    исключительно в рамках сервера и работает с чувствительными данными, что способствует безопасности. Также в примере
    показано как из одной модели получить словарь model_dump и перенести его в другую модель. Оператор ** который
    позволяет извлечь данные из словаря и использовать часть именованных аргументов, что аналогично kwargs (более
    подробно про распаковку/упаковку моделей рассказывается в моем репозитории pydantic в разделе
    сериализация/десериализация моделей).

    lsn6_5 - пример использования нескольких разных моделей, но с уменьшенным дублированием кода, а именно сокращение
    количества полей, за счёт наследования моделей. Развитие примера lsn6_4, только с более правильным типом записи
    моделей избегая дублирующихся полей в моделях и следованию принципу DRY.

    lsn6_6 - несколько вариантов возвращаемых моделей, использование Union в response_model для того, чтобы указать
    fastapi, что модель может быть одной из нескольких перечисляемых response_model=Union[model1, model2, model3].
    Пример где возвращается одна из нескольких моделей.

    lsn6_7 - дополнительные возвращаемые ответы сервера. Несколько моделей, списки, словари (так же управление
    выдаваемыми ключами с помощью response_model_exclude как в lsn6_3) и так далее. Аннотация возвращаемых типов через
    response_model, что необходимо для отображения этого в документации.

    lsn6_8 - редирект для GET запроса -> объект RedirectResponce, с передачей url перенаправления и статуса
    перенаправления: 301 - постоянный редирект, 302 - временный редирект (по умолчанию).

HTTP коды статуса ответа:

    lsn7_1 - статус коды в декораторах функций операций пути, использование модуля status (импортированного из Fastapi),
    который содержит в себе Enum перечисления с удобными информативными названиями статус кодов.

Прием данных из html форм (тег <form> и поля input внутри):

    lsn8_1 - Query параметры и метод отправки Html формы get, по умолчанию (или с явным методом get) html форма значения
    из input передаёт как query параметры. Это первый урок где html и fastapi наконец то встретились между собой.

    lsn8_2 - прием данных из формы, объект Form(), для каждого параметра формы прописывается отдельный параметр в
    функции. Параметры Form() и Body() не совместимы (то есть нельзя принять в одном энпоинте их одновременно), так как
    это разные типы контента -> Form это application/x-www-form-urlencoded (multipart/form-data в случае если это
    файлы). А в случае с Boody() это json и его тип контента application/json.
    (ВАЖНО! ПОЛЯ ДОЛЖНЫ СОВПАДАТЬ ПО ИМЕНИ С ПОЛЯМИ ФОРМЫ)

    lsn8_3 - Использование pydantic моделей, для работы с формами, Form() поддерживает модели, но в таком случае их
    нужно связать через Annotated (тип модели и объект Form()).
    (ВАЖНО! ПОЛЯ ДОЛЖНЫ СОВПАДАТЬ ПО ИМЕНИ С ПОЛЯМИ ФОРМЫ)

    lsn8_4 - приём файлов в fastapi, объект File() который позволяет передавать дополнительные метаданные.
    два способа: 1. Через bytes, файл сохраняется в оперативную память, такой способ
    подходит только для работы с небольшими файлами. Рискован для работы с большими, так как файл может занять всю
    память и привести к сбою приложения и даже сервера. 2. UploadFile, предпочтительный способ для работы с файлами, он
    сохраняет большие файлы в оперативной памяти до определенного размера, потом создаёт временные файлы на диске и если
    они не были прочитаны или сохранены, то удаляет их. Имеет методы filename, content_type для определения типа
    контента, а также метод read(), который позволяет читать данные в байтах, важно все операции с файлами нужно
    выполнять в асинхронном режиме (await) иначе при сильно долгих операциях возможно зависание маршрута.

    lsn8_5 - одновременная загрузка и файлов и данных из формы, тип кодировки контента multipart/form-data, этот урок
    рассматривает как комбинировать темы изученные в разделе lsn8_x. Fastapi поддерживает одновременный приём файлов и
    данных из формы, для этого нужно точно аннотировать поля в сигнатуре функции, а в html форме в enctype прописать тип
    "multipart/form-data" и верно установить типы полей input.

Обработка ошибок в fastapi:

    lsn9_1 - вызов исключения, объект HTTPException для отправки ошибки клиенту. HTTPException содержит статус код и
    детализацию ошибки, а также можно добавлять свои пользовательские заголовки, они начинаются с префикса "X-",
    например headers={"X-Error" : "FileNotFound"}

    lsn9_2 - обработчики исключений, exception_handler которые позволяют выносить логику обработки ошибки в отдельный
    модуль что очень удобно. Определение пользовательских исключений.

    lsn9_3 - обработчики стандартных исключений Fastapi. HTTPException (который наследуется от starlette.exceptions
    HTTPException), благодаря чему можно централизованно обрабатывать исключения HTTP. Обработчик RequestValidationError
    который позволяет переопределить поведение fastapi в случае неправильно введенных пользователем данных, например
    выполнить логирование, изменить формат вывода ошибки, и так далее.
    Отправка пользователю ответа в виде простой строки PlainTextResponse.

    lsn9_4 - обработка неверно введенных данных пользователем RequestValidationError, вынесение логики в отдельный
    обработчик.

Конфигурация операций пути как он влияет на документацию:

    lsn10_1 - указание дополнительных параметров конфигурации пути: статус коды (прописываются явно), группировка
    маршрутов по тегам (список tags), summary для названия маршрута в документации, description - краткое описание
    функции операции пути. docstring с markdown для красиво форматированного описания функции операции пути. Описание
    возвращаемого ответа с помощью response_description. Предупреждение об устаревании маршрута depricated.
    Оформление документации.

Json кодировщик:

    lsn11_1 - jsonable_encoder - кодировщик данных из модели в данные поддерживаемые json, аналог model_dump
    (метод pydantic моделей).

Частичное обновление данных модели в body параметрах:

    lsn12_1 - иногда бывает ситуация когда нужно обновить только часть атрибутов данных через модель. Для этого
    создается отдельный path слой запроса и в нем реализуется логика отсечения не переданных ключей exclude_unset=True,
    и метод модели copy с режимом update=Model... Важно! Для поддержки обновления по части полей, нужна дополнительная
    промежуточная модель в которой ключи установлены по умолчанию.

    lsn12_2 - реализация частичного обновления параметров модели на pydantic, как это работает у fastapi под капотом.


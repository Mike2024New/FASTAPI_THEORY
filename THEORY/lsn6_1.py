from UTILS.APP_RUN import app_run
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field, ConfigDict
from typing import Any, Annotated

# http://127.0.0.1:8000/docs
# http://127.0.0.1:8000/redoc
app = FastAPI()
app.name = "app"

"""
Функции операции пути (энпоинты) также могут и возвращать модели, при этом нужно указать возвращаемый тип модели
самый простой способ это указать возвращаемый тип в сигнатуре функции.
"""


class OutData(BaseModel):  # возвращаемая модель для теста (ex1)
    test1: int
    test2: int


@app.get("/ex1/")
def ex1() -> OutData:  # указание, что энпоинт вернет модель OutData, в случае возвращения других типов будет ошибка
    out_data = OutData(test1=123, test2=456)
    return out_data


"""
ex2 -> возвращаемый тип данных если это модель нужно указывать в response_model, он имеет высший приоритет и фактически
указанный выходной тип dict[str, int], который не соотвествует модели не имеет значения. Так как на выходе возвращается 
словарь который вообще ни как не соотносится с моделью и не проходит валидацию, то возникнет ошибка выходных данных и
на стороне клиента будет получен статус код 500 Internal Server Error, это делается для того, чтобы клиент не мог видеть
скрытую структуру сервера или спалить какие то чувствительные данные которые могли бы содержаться в локализации ошибки.
Это ошибка сервера, значит она отображается только серверу.
==================
Отсюда правило! 
Все выходные модели проводить через response_model и возвращать результат соответствующий.
-----------------
Также можно просто возвращать словарь поля в котором будут валидны для модели на выходе (как пример return {"test": 123}
в ex2). Такой способ удовлетворит для сигнатуры функции -> dict[str,int] и объявлению в @app.get -> response_model=Data 
"""


class Data(BaseModel):
    test1: int
    test2: int


@app.get("/ex2/", response_model=Data)
def ex2(data: Annotated[Data, Query()]) -> dict[str, int]:
    print(data)
    return {"test1": 123, "test2": 456}  # вывод корректный, так как этот словарь прочитается pydantic в модель
    # return {"test": 123}  # вызовет ошибку 500 Internal Server Error, вывод не соответствует response_model


"""
ex3, ex4 ->  примеры разделения входных и выходных данных
"""

"""
ex3 -> опция response_model указывает именно ту модель которая будет возвращена пользователю
модель UserIn - это та модель которая будет принята сервером от пользователя (она содержит чувствительные данные, такие
как пароль и кодовое слово).
модель UserOut - это та модель которая будет возвращена пользователю, как видно в ней чувствительные поля отсутствуют. 
Это может пригодиться например в тех случаях когда пользователь зарегистрировался и ему после успешной регистрации 
пишется пользователь с таким то name, зарегистрирован (при этом ни какие пароли естественно не показываются).
Выходная модель указывается в декораторе операции пути (энпоинта), в параметре response_mode.
============================================================================================
Это очень важный паттерн способствующий обеспечению безопасности
Не лишним в таких случаях будет использовать extra='forbid' в конфигурации модели, это даст дополнительную защиту
"""


class UserIn(BaseModel):
    name: str = Field(example="Ivan")
    age: int = Field(ge=18, le=60, example=30)
    password: str  # это поле чувствительно, здесь оно будет работать только на прием данных
    code_word: str  # это поле чувствительно, здесь оно будет работать только на прием данных
    model_config = ConfigDict(extra="forbid")  # как доплнительная защита от лишних ключей


class UserOut(BaseModel):  # в этой модели нет поля password, она будет возвращаться пользователю
    name: str
    age: int = Field(ge=18, le=60)
    model_config = ConfigDict(extra="forbid")  # как доплнительная защита от лишних ключей


@app.post("/ex3/", response_model=UserOut)  # в таком случае крайне важно указывать возвращаемую модель в response_model
def ex3(user: UserIn) -> Any:
    ...  # здесь внутренняя логика по сохранения пользователя в БД и так далее
    # в return ниже выполняется автопреобразование модели UserIn в UserOut
    return user  # user преобразованный из модели UserIn (содержащ чувствительные данные такие как пароль) в модель
    # UserOut в которой отсутствуют чувствительные данные.


"""
ex4 -> 
также можно использовать альтернативу обработки двух моделей используя наследование классов, сперва объявляется базовый
класс который содержит основные поля (те которые публичные), а потом уже объявляется класс наследник содержащий более
чувствительные параметры и на входе в маршрут применяется модель на базе этого класса. А возвращается пользователю 
базовая модель, тогда можно обойтись типизацией в сигнатуре функции, вернув базовую модель, fastapi и pydantic под 
капотом на выходе выполнят преобразование обратно в базовую модель (это спрятано в декораторе app).
Не лишним в таких случаях будет использовать extra='forbid' в конфигурации модели, это даст дополнительную защиту.
Также может потребоваться защитить модель от случайного изменения на сервере, для этого используется опция frozen=True
в ConfigDict, она делает модель immutable, то есть не изменяемой.
"""


class BaseUser(BaseModel):
    name: str = Field(example="Ivan")
    age: int = Field(ge=18, le=60, example=30)


class UserInputData(BaseUser):
    password: str  # это поле чувствительно, здесь оно будет работать только на прием данных
    code_word: str  # это поле чувствительно, здесь оно будет работать только на прием данных
    model_config = ConfigDict(
        extra="forbid",  # как дополнительная защита от лишних ключей
        frozen=True,  # модель можно защитить от изменения полей, по ошибке на сервере например
    )


@app.post("/ex4/")
def ex4(user: UserInputData) -> BaseUser:  # в сигнатуре функции указана правильная выходная модель, можно не бояться теперь
    # user.name = "Unknow" # вызовет ошибку 500 Internal Server Error, так как стоит защита frozen=True, на изменение модели
    return user  # на выходе будет BaseUser, не содержащая чувствительных данных


if __name__ == '__main__':
    app_run(file=__file__, app_name=app.name)

from UTILS.APP_RUN import app_run
from fastapi import FastAPI, Depends
from typing import Annotated

# http://127.0.0.1:8000/
# http://127.0.0.1:8000/docs/
# http://127.0.0.1:8000/redoc/
app = FastAPI()
app.name = "app"

"""
В di функциях можно объявлять ключевое слово yield, в таком случает действие будет выполнено до этого слова перед 
запросом, и за словом yield после запроса (отработки функции операции пути). Это позоволяет разделить логику работы
функции на следующую цепочку:
функция зависимости (перед yield) -> функция операции пути (api ручка) -> функция зависимости (после yield)
---------------------------------------------------------------------------------------------------------------------
yield в fastapi также как и в python генераторах может возвращать значение.
Часто такую конструкцию используют для работы с базами данных. Например один запрос это одна сессия подключения к БД,
сперва создали сессию, выполнился запрос, сессия закрыта.
yield может быть только один в функции зависимости
---------------------------------------------------------------------------------------------------------------------
Ниже показан пример работы с такой псевдо БД.
"""


async def get_db():
    db = {"session": True}
    print("get_db: открытие соединения с БД")
    try:
        # ровно до этой части отработает код перед вызовом маршрута, дальнейшие действия произойдут после срабатывания функции операции пути
        yield db  # yeield возвращает значение
    except Exception as err:
        print(err)  # точка логирования ошибки
    finally:
        print(f"get_db: Соединение завершено")
        db["session"] = False
        # такая конструкция с yield может вызвать только одно исключение
        # x = 10 / 0  # исключения возникшие после запроса будут также блокировать соединение с ошибкой 500


async def get_data_bd(db_session: Annotated[dict, Depends(get_db)]):
    print(f"get_data_bd: берутся данные из БД, статус сессии {db_session}")


# http://127.0.0.1:8000/ex1/
@app.get("/ex1/", dependencies=[Depends(get_data_bd)])
async def ex1():
    print("ex1: обработка запроса в endpoint")
    return {"msg": "ex1"}


if __name__ == '__main__':
    app_run(file=__file__, app_name=app.name)
